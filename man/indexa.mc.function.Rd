% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R, R/indexa.mc.R
\name{indexa.mc}
\alias{indexa.mc}
\alias{indexa.mc.function}
\alias{Generates}
\alias{Monte}
\alias{Carlo}
\alias{samples}
\alias{from}
\alias{the}
\alias{Multinomial-Dirichlet}
\alias{distribution}
\alias{for}
\alias{each}
\alias{sample}
\alias{in}
\alias{a}
\alias{given}
\alias{matrix}
\alias{of}
\alias{sequence}
\alias{counts.}
\alias{These}
\alias{provide}
\alias{estimates}
\alias{microbial}
\alias{or}
\alias{gene}
\alias{composition,}
\alias{which}
\alias{are}
\alias{then}
\alias{used}
\alias{to}
\alias{compute}
\alias{scale}
\alias{and}
\alias{absolute}
\alias{abundance.}
\alias{The}
\alias{resulting}
\alias{\code{indexa.mc}}
\alias{object}
\alias{serves}
\alias{as}
\alias{input}
\alias{further}
\alias{analyses.}
\title{Compute an \code{indexa.mc} Object using Monte Carlo Sampling}
\usage{
indexa.mc(reads, mc.samples = 250, denom = "none", custom.scale = NULL)

indexa.mc.function(
  reads,
  mc.samples = 250,
  denom = "none",
  custom.scale = NULL
)
}
\arguments{
\item{reads}{A matrix of measured sequence counts, where each row represents a gene,
microbe, or taxon, and each column represents a measured sample.}

\item{mc.samples}{An integer specifying the number of Monte Carlo samples to generate.
DEFAULT: 250}

\item{denom}{A parameter for specifying the method used to calculate the scale. Options include:
\describe{
\item{"none"}{(Default) No normalization. Use this option when specifying an interval over
the LFC in scales. For example, if the total microbial load (i.e., scale) is expected
to increase by up to 2.5-fold between treatment and control conditions, use
"none" and specify the interval \code{c(0, log2(2.5))} in the next step.}
\item{"all"}{Equivalent to Centered Log-Ratio (CLR) normalization as in ALDEx2. Use this
when specifying an interval assumption to account for error in CLR normalization.}
\item{numeric vector}{Specifies row indices in the \code{reads} matrix (i.e., the genes/microbes) to
use for normalization. This option allows normalization with housekeeping
genes, under the assumption these genes or microbes have LFCs of \code{0}. An
interval assumption in the next step would account for errors in this
assumption.}
}}

\item{custom.scale}{A custom function for specifying the scale, intended for advanced use cases.
This function should accept a three-dimensional array (with dimensions corresponding to the number
of rows in \code{reads}, the number of samples, and \code{mc.samples}) and return a matrix. The
returned matrix should have \code{mc.samples} rows and the same number of columns as the \code{reads} matrix.
The returned matrix of the custom function should be log2 values representing the scale in each sample
for each monte carlo sample. The output of the custom matrix is then added to the log2 estimated
proportions to obtain the log2 absoute abundance values used in the next step. See examples below
for how to define \code{custom.scale}.}
}
\value{
An \code{indexa.mc} object.
}
\description{
Compute an \code{indexa.mc} Object using Monte Carlo Sampling
}
\examples{
   # The 'reads' matrix has microbes/genes for the rows
   # and samples for the columns. Like:
   #
   #            sample_1  sample_2  sample_3 ...etc...
   # microbe_1         0         3         7
   # microbe_2        12        23         0
   # microbe_3       212         0        98
   # ... etc ...

# Simple sequence count data
Y <- rbind(c(4,0,1,9), c(5,1,9,0))
colnames(Y) <- c("control_1", "control_2", "treatment_1", "treatment_2")
rownames(Y) <- c("microbe_1", "microbe_2")

# Example 1: No normalization, log2 transformed proportions
indexa.obj <- indexa.mc(Y, mc.samples=1000)

# Example 2: CLR normalization (default in ALDEx2)
indexa.obj.clr <- indexa.mc(Y, denom="all", mc.samples=1000)

# Example 3: Custom scale function (equivalent to CLR normalization)
custom.func <- function(dirichlet.samples) {
  return(-log2(apply(dirichlet.samples, c(3,2), gm.mean)))
}
indexa.obj.clr <- indexa.mc(Y, custom.scale=custom.func, mc.samples=1000)

# Example 4: Custom scale function (equivalent to denom="none")
custom.func <- function(dirichlet.samples) {
  return(matrix(0, nrow=dim(dirichlet.samples)[3], ncol=dim(dirichlet.samples)[2]))
}
indexa.obj.clr <- indexa.mc(Y, custom.scale=custom.func, mc.samples=1000)

}
